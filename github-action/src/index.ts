import * as core from '@actions/core';
import * as github from '@actions/github';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Evidence pack structure from Diachron CLI
 */
interface EvidencePack {
  pr_id: number;
  generated_at: string;
  diachron_version: string;
  summary: {
    files_changed: number;
    lines_added: number;
    lines_removed: number;
    tool_operations: number;
    sessions: number;
  };
  commits: Array<{
    sha: string;
    message?: string;
    events: Array<{
      tool_name: string;
      file_path?: string;
      operation?: string;
    }>;
    confidence: 'High' | 'Medium' | 'Low';
  }>;
  verification: {
    chain_verified: boolean;
    tests_executed: boolean;
    build_succeeded: boolean;
    human_reviewed: boolean;
  };
  intent?: string;
  coverage_pct: number;
  unmatched_count: number;
}

/**
 * Render evidence pack as markdown comment
 */
function renderMarkdown(pack: EvidencePack): string {
  let md = '';

  // Header
  md += `## PR #${pack.pr_id}: AI Provenance Evidence\n\n`;

  // Intent section (if available)
  if (pack.intent) {
    md += `### Intent\n`;
    md += `> ${pack.intent}\n\n`;
  }

  // Summary section
  md += `### What Changed\n`;
  md += `- **Files modified**: ${pack.summary.files_changed}\n`;
  md += `- **Lines**: +${pack.summary.lines_added} / -${pack.summary.lines_removed}\n`;
  md += `- **Tool operations**: ${pack.summary.tool_operations}\n`;
  md += `- **Sessions**: ${pack.summary.sessions}\n\n`;

  // Evidence trail section
  md += `### Evidence Trail\n`;
  md += `- **Coverage**: ${pack.coverage_pct.toFixed(1)}% of events matched to commits`;
  if (pack.unmatched_count > 0) {
    md += ` (${pack.unmatched_count} unmatched)`;
  }
  md += '\n';

  for (const commit of pack.commits) {
    const shaShort = commit.sha.substring(0, 7);
    md += `\n**Commit \`${shaShort}\`**`;
    if (commit.message) {
      const firstLine = commit.message.split('\n')[0];
      md += `: ${firstLine}`;
    }
    md += ` (${commit.confidence})\n`;

    for (const event of commit.events) {
      const file = event.file_path || '-';
      const op = event.operation || '-';
      md += `  - \`${event.tool_name}\` ${op} â†’ ${file}\n`;
    }
  }
  md += '\n';

  // Verification section
  md += `### Verification\n`;
  md += `- [${pack.verification.chain_verified ? 'x' : ' '}] Hash chain integrity\n`;
  md += `- [${pack.verification.tests_executed ? 'x' : ' '}] Tests executed after changes\n`;
  md += `- [${pack.verification.build_succeeded ? 'x' : ' '}] Build succeeded\n`;
  md += `- [${pack.verification.human_reviewed ? 'x' : ' '}] Human review\n\n`;

  // Footer
  md += `---\n`;
  md += `*Generated by [Diachron](https://github.com/wolfiesch/diachron) v${pack.diachron_version} at ${pack.generated_at}*\n`;

  return md;
}

/**
 * Find existing Diachron comment on PR
 */
async function findExistingComment(
  octokit: ReturnType<typeof github.getOctokit>,
  owner: string,
  repo: string,
  prNumber: number
): Promise<number | null> {
  const { data: comments } = await octokit.rest.issues.listComments({
    owner,
    repo,
    issue_number: prNumber,
  });

  const diachronComment = comments.find(
    (comment) =>
      comment.body?.includes('AI Provenance Evidence') &&
      comment.body?.includes('Diachron')
  );

  return diachronComment?.id ?? null;
}

async function run(): Promise<void> {
  try {
    // Get inputs
    const token = core.getInput('github-token', { required: true });
    const evidencePath = core.getInput('evidence-path');
    const commentMode = core.getInput('comment-mode');
    const failOnMissing = core.getInput('fail-on-missing') === 'true';

    // Get PR context
    const context = github.context;
    if (!context.payload.pull_request) {
      core.info('Not a pull request event, skipping');
      return;
    }

    const prNumber = context.payload.pull_request.number;
    const owner = context.repo.owner;
    const repo = context.repo.repo;

    core.info(`Processing PR #${prNumber} in ${owner}/${repo}`);

    // Check for evidence file
    const fullPath = path.resolve(evidencePath);
    if (!fs.existsSync(fullPath)) {
      const message = `Evidence file not found: ${evidencePath}`;
      if (failOnMissing) {
        core.setFailed(message);
        return;
      }
      core.warning(message);
      core.info('Skipping PR comment (no evidence available)');
      return;
    }

    // Read and parse evidence
    const evidenceJson = fs.readFileSync(fullPath, 'utf-8');
    const evidence: EvidencePack = JSON.parse(evidenceJson);

    core.info(`Evidence loaded: ${evidence.summary.tool_operations} operations, ${evidence.coverage_pct.toFixed(1)}% coverage`);

    // Render markdown
    const markdown = renderMarkdown(evidence);

    // Create GitHub client
    const octokit = github.getOctokit(token);

    // Check for existing comment
    let commentId: number | null = null;
    if (commentMode === 'update') {
      commentId = await findExistingComment(octokit, owner, repo, prNumber);
    }

    // Post or update comment
    if (commentId) {
      core.info(`Updating existing comment #${commentId}`);
      await octokit.rest.issues.updateComment({
        owner,
        repo,
        comment_id: commentId,
        body: markdown,
      });
    } else {
      core.info('Creating new comment');
      const { data: newComment } = await octokit.rest.issues.createComment({
        owner,
        repo,
        issue_number: prNumber,
        body: markdown,
      });
      commentId = newComment.id;
    }

    // Set outputs
    core.setOutput('comment-id', commentId);
    core.setOutput('coverage', evidence.coverage_pct);
    core.setOutput('verified', evidence.verification.chain_verified);

    core.info(`Successfully posted Diachron evidence to PR #${prNumber}`);
  } catch (error) {
    if (error instanceof Error) {
      core.setFailed(error.message);
    } else {
      core.setFailed('An unexpected error occurred');
    }
  }
}

run();
